<?php
/**
 * @file
 * Headless Authoring eXperience, all we do is accept calls and make things haxable in the first place.
 */

/**
 * Implements hook_permission().
 */
function hax_permission() {
  return array(
    'use hax' =>  array(
      'title' => t('Use HAX editor'),
      'description' => t('Advanced authoring experience that is pulled in from hax capable web components.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function hax_menu() {
  // hax-endpoint/update/node/123-123-4342-11cd/1333f-ffdd223f-sfad-adsdsdd
  // callback path, operation, entity type, uuid, session token
  $items['hax-endpoint/%/%/%/%'] = array(
    'title' => 'HAX API callback',
    'description' => 'HAX API endpoint',
    'page callback' => '_hax_endpoint',
    'page arguments' => array(1, 2, 3, 4),
    'type' => MENU_CALLBACK,
    'access callback' => '_hax_endpoint_access',
    'access arguments' => array(1, 2, 3, 4),
  );
  return $items;
}

/**
 * Access callback to ensure hax can be used on this node
 */
function _hax_endpoint_access($op, $etype, $uuid, $token) {
  // most basic of checks for permission vars set and session token hash
  if (user_access('use hax') && !empty($op) && !empty($etype) && !empty($uuid) && !empty($token) && drupal_valid_token($token, 'hax')) {
    // try and load the entity by uuid, simplifies implementations
    $entities = entity_uuid_load($etype, array($uuid));
    // pop one off if we got anything, otherwise let this fail
    if (is_array($entities) && !empty($entities)) {
      $entity = array_pop($entities);
      // ensure they have access to perform this operation on this entity in general
      if (entity_access($op, $etype, $entity)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Callback to perform the operation on the entity as per update
 * @return [type] [description]
 */
function _hax_endpoint($op, $etype, $uuid, $token) {
  $vars = array('status' => 100);
  $entity = new stdClass();
  $info = entity_get_info($etype);
  // silly check, ensure this has a concept of keys
  if (isset($info['entity keys']['id'])) {
    switch ($op) {
      // update the only real one for now
      case 'update':
        $properties = _hax_sanitize($_GET['properties']);
        // ensure we know about this display mode
        if ($webcomponent = webcomponent_load_by_name($properties['tagName'])) {
          // dump this now that it's a full object
          unset($properties['tagName']);
          // starting to look like we might be able to do soemthing with all this..
          $vars['status'] = 200;
          // try and load the entity by uuid, simplifies implementations
          $entities = entity_uuid_load($etype, array($uuid));
          // pop one off if we got anything, otherwise let this fail
          if (is_array($entities) && !empty($entities)) {
            $entity = array_pop($entities);
            if (isset($entity->{$info['entity keys']['id']})) {
              // hook in the fields relative to this webcomponent being the display mode
              field_attach_prepare_view($etype, array($entity->{$info['entity keys']['id']} => $entity), $webcomponent->machine_name);
              entity_prepare_view($etype, array($entity->{$info['entity keys']['id']} => $entity));
              $field_map += field_attach_view($etype, $entity, $webcomponent->machine_name);
            }
          }
          $changed = FALSE;
          // now we run through the properties and do our map back
          foreach ($field_map as $key => $value) {
            // so our field map illustrates that there's soemthing rendered in a matching
            // location for this, now we can dig into the array structure a bit
            if (isset($properties[$key])) {
              //@todo do the match of what came across with what's been mapped in the DB
              //and then save it back to the entity
              $changed = TRUE;
              //this is completely fake code but soemthign like this
              //$entity->{$value['#field_name']} = $properties['value'];
            }
          }
          // only save if we actually got a match to save in the first place
          if ($changed) {
            entity_save($etype, $entity);
          }
        }
      break;
      // nothing to support this yet
      case 'insert':
      break;
    }
  }
  drupal_add_http_header('Content-Type', 'application/json');
  // define status
  drupal_add_http_header('Status', $vars['status']);
  // output the response as json
  print drupal_json_output($vars);
}

/**
 * Ensure this is a simple array and nothing evil is there.
 * @param  array $properties array of values from the front end
 * @return array             cleaned out value set
 */
function _hax_sanitize($properties) {
  // filter out potentially nasty things coming back in house
  foreach ($properties as $key => $value) {
    // ensure this pass back is as simple as possible
    if (!is_array($value)) {
      $properties[filter_xss($key)] = filter_xss($value);
    }
    else {
      unset($properties[$value]);
    }
  }
  return $properties;
}

/**
 * Implements hook_hax_webcomponent_render_alter().
 * Make sure we wrap on the haxable property and ajax submitter
 */
function hax_webcomponent_render_alter(&$vars, $webcomponent) {
  if (user_access('use hax')) {
    $hide = '';
  }
  else {
    $hide = 'hide-hax';
  }
  // apply tag wrapper so that this element knows it CAN use ajax to submit... most likely
  $vars['wrap_tag'] = '<hax-ajax ' . $hide . ' url="' . base_path() . '/hax-endpoint/update/node/123-123-4342-11cd/' . drupal_get_token('hax') . '">';
  $vars['wrap_tag_close'] = '</hax-ajax>';
}
